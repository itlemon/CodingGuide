# 第2节 数组的二分查找算法

> 学习了 [第1节 数组理论基础](1-1数组的理论基础.md) ，相信读者已经对数组这种基本数据结构有了基本的认识，接下来，我们通过一个案例入手，一起学习一下数组的『二分查找』算法。

## 一、经典案例

这里给定一个基础案例，这个案例其实就是 [leetcode](https://leetcode.cn/) 上的 `第704题` ，题目内容如下所示：

**描述：**给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target` ，如果目标值存在返回下标，否则返回 `-1` 。

**示例1：**

```java
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```java
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

看到这道题，我们第一感觉就是很简单，没错，它在 `leetcode` 上被标注为一道 <Badge type="tip" text="简单" vertical="middle" /> 题，正常情况下，刚开始接触 `leetcode` 的时候，我们往往会去遍历它，通过遍历可以很快将目标元素的下标给输出出来，我们一起来看一下下面的图，并写出代码。

![image-20221023221845295](https://codingguide-1256975789.cos.ap-beijing.myqcloud.com/codingguide/img/image-20221023221845295.png)

上图描述的很清晰，我们从左往右进行遍历：第一个元素 `-1` 不等于 `9` ，接下来遍历第二个元素 `0` ，它同样不等于 `9` ，继续往后遍历，当遍历到第五个元素的时候，发现它等于 `9` ，那么返回它的下标为 `4` 。

要在上述数组中查找元素 `2` ，也是采用同样从左往右的方式，发现数组中并没有等于 `2` 的元素，那么遍历结束后，直接返回 `-1 `。

也很好理解，我们这里直接写出代码如下：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 对每一个元素进行遍历
        for (int i = 0; i < nums.length; i++) {
            // 如果数组中某个元素等于目标元素，则直接返回元素下标
            if (target == nums[i]) {
                return i;
            }
        }
        
        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

复杂度分析：

- 时间复杂度： `O(n)`
- 空间复杂度： `O(1)`

我们做完这一道题，也分析了时间复杂度，那么有办法降低这个时间复杂度吗？或者说，有更优的解法吗？答案是当然有，它就是本节的重点要介绍的解法： `二分查找法` 。

## 二、二分查找法

