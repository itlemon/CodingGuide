# 第2节 数组的二分查找算法

> 学习了 [第1节 数组理论基础](1-1数组的理论基础.md) ，相信读者已经对数组这种基本数据结构有了基本的认识，接下来，我们通过一个案例入手，一起学习一下数组的『二分查找』算法。

## 一、经典案例

这里给定一个基础案例，这个案例其实就是 [leetcode](https://leetcode.cn/) 上的 `第704题` ，题目内容如下所示：

**描述：**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target` ，如果目标值存在返回下标，否则返回 `-1` 。

**示例1：**

```java
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```java
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

看到这道题，我们第一感觉就是很简单，没错，它在 `leetcode` 上被标注为一道 <Badge type="tip" text="简单" vertical="middle" /> 题，正常情况下，刚开始接触 `leetcode` 的时候，我们往往会去遍历它，通过遍历可以很快将目标元素的下标给输出出来，我们一起来看一下下面的图，并写出代码。

![image-20221026000145092](https://codingguide-1256975789.cos.ap-beijing.myqcloud.com/codingguide/img/image-20221026000145092.png)

上图描述的很清晰，我们从左往右进行遍历：第一个元素 `-1` 不等于 `9` ，接下来遍历第二个元素 `0` ，它同样不等于 `9` ，继续往后遍历，当遍历到第五个元素的时候，发现它等于 `9` ，那么返回它的下标为 `4` 。

要在上述数组中查找元素 `2` ，也是采用同样从左往右的方式，发现数组中并没有等于 `2` 的元素，那么遍历结束后，直接返回 `-1 `。

通过图文的描述，我相信读者已经理解了，我们这里直接写出代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 对每一个元素进行遍历
        for (int i = 0; i < nums.length; i++) {
            // 如果数组中某个元素等于目标元素，则直接返回元素下标
            if (target == nums[i]) {
                return i;
            }
        }
        
        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

复杂度分析：

- 时间复杂度：$O(n)$
- 空间复杂度： $O(1)$

我们做完这一道题，也分析了时间复杂度，那么有办法降低这个时间复杂度吗？或者说，有更优的解法吗？答案是当然有，它就是本节的重点要介绍的解法： `二分查找法` 。

## 二、二分查找算法

### 2.1 什么是二分查找

何为 **『二分查找』** ？相信刚刚接触数据结构与算法的读者可能会懵，不急，我举个生活中出现过的例子，相信这类读者肯定会很快明白。

以前看过一档综艺节目，主持人手中有 `100` 牌，每张牌中都有一个数字，数字分别是从 `1` 到 `100` ，主持人让嘉宾随机抽取一张，然后主持人要在极短的时间内猜中嘉宾抽中的牌是哪一个数字（假设本次读者抽中的是 `79` ），主持人不可以直接问嘉宾牌上数字是多少，嘉宾只用回答 `是` 或者 `不是` ，那么这个时候，他们之间的对话就开始了。

**主持人：** “您手中的牌数字大于 `50` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌数字大于 `75` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌数字大于 `88` 吗？”

**嘉    宾：** “不是”

**主持人：** “您手中的牌数字大于 `81` 吗？”

**嘉    宾：** “不是”

**主持人：** “您手中的牌数字大于 `78` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌大于 `79` 吗？”

**嘉    宾：** “不是”

**主持人：** “我猜出来了，您手中的牌数字是 `79` ！”

**嘉    宾：** “恭喜您，答对了！”

相信这个综艺节目的这种案例大家都看过或者听过，主持人在问了嘉宾六个问题后，第七次就直接猜中了嘉宾抽取的牌数字。如果说，主持人从数字 `1` 开始挨个问：“您牌的数字是不是 `1` ...”，那么他需要问 `79` 次才能问中，假设主持从 `100` 倒序往前问，也得问 `21` 次才可以问到答案。

其实，主持人这种问法，正是经典的 **『减而治之』** 的思想，也是 **『二分查找算法』** 的应用。 **『减而治之』** 思想就是：一步步缩小问题范围，在小范围中去解决问题。主持人通过问嘉宾手中的牌数字是否比某个值大，从而来缩小范围，最终确定了范围是 `[79, 80]` ，那么通过最后一个问题直接判断出答案是 `79` 。

我们将 `1 ~ 100` 的牌理解为 `[1, 2, 3, ..., 99, 100]` 的数组，那么我们再来思考下何为 **『二分查找』** ，相信读者肯定就容易理解多了。顾名思义，就是将数组一分为二，排除掉不可能的二分之一数组，继续从剩下二分之一数组中去查找，这种查找算法最基本的条件就是数组要有序，它是一种在有序数组中查找某一特定元素的搜索算法。二分查找算法的叫法也很多，常见的有： **折半查找算法** 、 **对半查找算法** 、 **对数查找算法** 等。

上面的综艺节目的案例，其实是 **『二分查找算法』** 的 `排除法` 的应用，它直接排除了不可能的区间，直到最后只剩下一个元素，直接判断最后剩下的元素是否等于目标元素即可。其实还有一种思路，那就是 `主动找` ，它是  **『二分查找算法』** 里常见的思路，理解起来比 `排除法` 思路还简单一些。它的基本过程如下：

1. 拿到一个数组（默认数组有序）以后，直接找到数组的中间元素，如果中间元素正好等于目标元素，则搜索过程结束，直接返回中间元素的下标即可；
2. 如果目标元素大于（小于）中间元素，则在数组大于（小于）中间元素的那一半中查找，而且跟开始一样，从中间元素开始比较；
3. 如果找到最后，数组为空了，则代表找不到，返回 `-1` 即可。

对于这种 `主动找` 的思路，我也来举个例子，给定一个有序数组 `[1, 2, 4, 16, 17, 19, 20, 21, 23, 31, 39]` ，我们需要判断 `21` 是否在数组中，如果在，返回它在数组中的下标，如果不在，直接返回 `-1` 。

我们根据上面 `主动找` 的基本过程来看如何使用 **『二分查找算法』** 来快速找到结果：

1. 首先找到中间元素 `19` ，它不等于 `21` ，因为 `21` 比 `19` 大，所以，我们需要在大于 `19` 的那一半去接着找，此时寻找区间变成了`[20, 21, 23, 31, 39]` ；
2. 我们在 `[20, 21, 23, 31, 39]` 这一半找到中间元素 `23` ，它不等于 `21` ，它比 `21` 大，所以我们需要到小于 `23` 的那一半去接着找，此时寻找区间变成了 `[20, 21]` ；
3. 此时寻找空间就剩下两个元素，我们找中间元素，元素 `20` 的下标是 `6` ，元素 `21` 的下标是 `7` ，我们取两个下标之和除以 `2` ，在计算机整型中 **除以** 有向下取整的过程， `13 / 2 = 6` ，所以中间元素为 `20` ，此时继续判断 `21` 大于 `20` ，所以需要在 `20` 右边区间继续寻找，此时寻找区间变成了 `[21]` ；
4. 最后一步，自然而然， `21` 成为了中间元素，它等于目标元素，所以此时找到了结果，返回 `21` 的下标为 `7` 。

我们通过 **『二分查找算法』** 来搜索元素，只搜索了 `4` 次就找到了目标元素，如果挨个儿遍历，那也需要遍历 `8` 次才能找到，所以说， **『二分查找算法』** 是比普通遍历更优的算法。

### 2.2 使用语言实现二分查找算法

我们还是以第一小节中的经典案例来举例，我们这次尝试使用二分查找算法来解决这个搜索问题。首先，我们还是通过画图的形式，将过程展示出来，过程理清楚了，代码写起来就不难了，图文过程如下所示：

首先我们定义三个变量：

- left：左边界下标
- right：右边界下标
- mid：中间值下标

初始值设置为： $left = 0$ ， $right = nums.length - 1$ ， $mid = (left + right) / 2$

数组的搜索区间为 `[left, right]` ，中间值的下标为 `mid` ，我们按照 `主动找` 的思路来解决这个问题，基本步骤如下：

- 如果中间位置值 `nums[mid]` 与目标值 `target` 相等，则返回中间值下标；
- 如果中间位置值 `nums[mid]` 小于目标值 `target` ，说明如果目标值存在，则一定在中间值的右区间，此时将左边界设置为 `mid + 1` ，然后继续在右区间 `[mid + 1, right]` 中搜索；
- 如果中间位置值 `nums[mid]` 大于目标值 `target`，说明如果目标值存在，则一定在中间值的左区间，此时将右边界设置为 `mid - 1` ，然后继续在左区间 `[left, mid - 1]` 中搜索。

转换成图形式如下所示：

![image-20221026000105068](https://codingguide-1256975789.cos.ap-beijing.myqcloud.com/codingguide/img/image-20221026000105068.png)

从上面的图文可以看出，我们通过 2 次就找到了目标值，效率是杠杠的！

我们一起来看下代码如何实现，这里直接给出代码如下：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义三个变量
        int left = 0;
        int right = nums.length - 1;
        int mid;

        // 跳出循环的条件是 left > right，当left == right的时候，是最后一次循环，此时待查找区间只剩下一个元素
        // 如果最后一个元素不等于目标元素，说明数组nums里面不含目标元素，直接返回 -1
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

复杂度分析：

- 时间复杂度：$O(\log_{2}{n})$
- 空间复杂度： $O(1)$

### 2.3 二分查找中的细节分析

**『二分查找算法』** 的原理很简单，但是其中的细节是需要读者彻底弄明白，否则也是很容易出问题的，只有原理和细节都掌握了，那么对于这类算法题，解起来将得心应手。

这里列举 4 个大家常见的细节问题：

1. **搜索区间的开闭问题：** 在定义区间变量的时候，是选择 `左闭右闭` （也就是 `[ ]` ）还是 `左闭右开` （也就是 `[ )` ）？
2. **中间值下标取值问题：** 取 $mid = (left + right) / 2$ 还是 $mid = left + (right - left) / 2$ ？
3. **判断条件设置问题：** 判断条件该选 $left <= right$ 还是 $left < right$ ？
4. **搜索区间选择问题：** 区间边界该选 $left = mid + 1$ 、 $left = mid$ 、 $right = mid - 1$ 还是 $right = mid$ ？

是不是我这么一列举，你瞬间觉得自己又整不会啦？没关系，我们一起来一一分析一下这四个问题，分析清楚了，理解了，做题的时候才不会懵。

#### 2.3.1 搜索区间的开闭问题

在数组操作中，都要考虑边界问题，数组不能越界，比如数组长度为 3 ，它的元素下标分别为 `0, 1, 2` ，那么在取元素的时候，是取不到下标为 `3` 的元素的，因为它越界了。有了这个基础，我们来看看常见的两种边界定义方式：

- 左闭右闭：左右边界都是有意义的，$left = 0$ 、 $right = nums.length - 1$ 分别是数组 `nums` 的左边界和右边界， `left` 是 `nums` 的第一个元素， `right` 是 `nums` 最后一个元素，它的表示方式是 `[left, right]` 。
- 左闭右开：左边边界是有意义的，右边边界是超出数组的最后一个下标的，它是数组最后一个元素的下一个位置，左边边界是可以取到的，但是右边边界是取不到的， $left = 0$ 、 $right = nums.length$ ，它的表示方式是 `[left, right)` 。

如果上面的案例选择 `左闭右开` 的搜索区间，那么右边的值是始终取不到的，即不存在 $left == right$ 的情况 ，这个时候判断条件就需要有对应的变化，判断条件应该为 $left < right$ ，那么它退出循环的条件就是 $left == right$ ，换句话说，当 $left = right - 1$ 的时候，搜索区间就剩最后一个元素了，如果最后一个元素不是目标元素，那么说明整个数组中不包含目标元素，相应的代码如下所示：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义三个变量
        int left = 0;
        int right = nums.length;
        int mid;

        // 跳出循环的条件是 left == right，当left = right - 1的时候，是最后一次循环，此时待查找区间只剩下一个元素
        // 如果最后一个元素不等于目标元素，说明数组nums里面不含目标元素，直接返回 -1
        while (left < right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                // 右边是单开，所以只能是mid，不是mid - 1
                right = mid;
            }
        }

        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

这两种区间都可以选择，但是最常见的还是 `左闭右闭` ，读者在做 `leetcode` 算法题的时候，熟练掌握其中一种即可，整体推荐 `左闭右闭` 。

#### 2.3.2 中间值下标取值问题

关于中间值下标 `mid` 的取值，很多读者也挺迷惑，为什么迷惑呢，主要原因还是看了太多版本的解析了，常见的写法有好几种，看得读者眼花缭乱，始终弄不清楚该选择哪一种了，其实是没有弄明白其中的原理，咱们接下来列举常见的几种写法，并谈一谈它的原理， `mid` 常见的取值方式如下所示：

**第一种：** 向下取整，取左边。

意思就是说当数组的个数是偶数的时候，它取中间值的时候，以下两种常见写法都是取左边的，例如数组 `[1, 2, 3, 4, 5, 6]` ，它的中间值用下面两种计算方法，取的中间值是 `3` ，而不是 `4` 。计算方式是 $mid = (0 + 5) / 2 = 2$ ，$mid = 0 + (5 - 0) / 2 = 2$ ，计算公式如下：

- $mid = (left + right) / 2$
- $mid = left + (right - left) / 2$

这两种计算方式有何不同呢？其实在小范围内也没什么不同，第一个大家很好理解，就是首尾相加除以 `2` ，第二个写法，是为了防止整型溢出，什么意思呢？我以 `Java` 举例， `Integer` 类型的最大值是 *2147483647* ，假设某个数组最后一个元素的下标正好为 *2147483647* ，假设要寻找某个目标元素，它在整个数组的右半部分，此时当 left 设置为中间值的下标的时候，再次计算 `mid` 的时候，中间值下标和 *2147483647* 相加肯定会超过 `Integer` 类型的最大值，此时程序会报错，此时第二种写法就成为了第一种写法的替代者，它不会造成整型溢出。所以在处理 `leetcode` 问题的时候，考虑使用哪种方式，取决于数组的最后一个元素下标会不会造成整型溢出，如果不会造成，为了问题简单化，我推荐第一种写法，如果你想求稳，第二种写法适合你。

**第二种：** 向上取整，取右边。

可能有读者会问，取右边可以吗，当然可以。想取右边，只需要稍微变动一下公式即可，如下所示：

- $mid = (left + right + 1) / 2$
- $mid = left + (right - left + 1) / 2$

读到这里，其实大家应该能理解，二分查找，并不一定取值一定是在正中间，靠左一点，靠右一点都是可以的，关键是需要理解取值的方式之间的区别即可。

这里发散一下思维：既然有 **『二分查找算法』** ，那么是否可以有 **『三分查找算法』** 、**『四分查找算法』** 甚至是 **『五分查找算法』** ，其实是可以有的，假设使用 **『五分查找算法』** ，如果目标元素在前五分之一，那么效果是比二分查找要好的，其实这也是一种“赌博”的心态，总体来说，二分查找算法更加稳定。

#### 2.3.3 判断条件设置问题

在二分查找中，对于判断条件的写法，常见的通常有两种：

- $left <= right$
- $left < right$

至于该选择哪个，其实和区间的开闭有关系，我们针对 `左闭右闭` 和 `左闭右开` 这两种区间类型都分析一下，接下来的内容不需要记忆，只需要理解即可，理解后，无论哪种区间类型，都能正确地应用判断条件。

在 `左闭右闭` 的区间类型下：

如果选择 $left <= right$ ，那么判断语句的结束条件就是 $left == right + 1$ ，此时左边界比右边界还大，这样的查找空间是不存在的，比如 `[3, 2]` ，待搜索的区间中没有任何元素存在，此时直接返回 `-1` 即可。这个示例代码直接参考上面 `2.2` 的内容即可。

如果选择 $left < right$ ，那么判断语句的结束条件 $left == right$ ，此时左右边界相等，此时搜索区间中其实还有一个元素，此时直接返回 -1 是不对的，因为漏掉了一个元素没有进行对比，区间 `[right, right]` 是有意义的。如果非要使用这个判断条件，那么应该在跳出循环后，再做一次判断，判断目标元素是否等于 `nums[left]` ，如果等于，则返回 `left` ，否则返回 `-1` 。这个示例代码如下所示：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义三个变量
        int left = 0;
        int right = nums.length - 1;
        int mid;

        // 跳出循环的条件是 left == right，当left = right - 1的时候，是最后一次循环，此时待查找区间只剩下两个元素
        // 检查完 right - 1 的元素后，就跳出了，少检查了一个 right的元素，也就是这种判断条件在循环体中漏掉了一个元素
        while (left < right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        // 最后还要检查循环体没有检查的元素才能得出正确结果
        return nums[left] == target ? left : -1;
    }
}
```







#### 2.3.4 搜索区间选择问题



