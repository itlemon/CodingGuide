# 第2节 数组的二分查找算法

> 学习了 [第1节 数组理论基础](1-1数组的理论基础.md) ，相信读者已经对数组这种基本数据结构有了基本的认识，接下来，我们通过一个案例入手，一起学习一下数组的『二分查找』算法。

## 一、经典案例

这里给定一个基础案例，这个案例其实就是 [leetcode](https://leetcode.cn/) 上的 `第704题` ，题目内容如下所示：

**描述：**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target` ，如果目标值存在返回下标，否则返回 `-1` 。

**示例1：**

```java
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例2：**

```java
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

看到这道题，我们第一感觉就是很简单，没错，它在 `leetcode` 上被标注为一道 <Badge type="tip" text="简单" vertical="middle" /> 题，正常情况下，刚开始接触 `leetcode` 的时候，我们往往会去遍历它，通过遍历可以很快将目标元素的下标给输出出来，我们一起来看一下下面的图，并写出代码。

![image-20221026000145092](https://codingguide-1256975789.cos.ap-beijing.myqcloud.com/codingguide/img/image-20221026000145092.png)

上图描述的很清晰，我们从左往右进行遍历：第一个元素 `-1` 不等于 `9` ，接下来遍历第二个元素 `0` ，它同样不等于 `9` ，继续往后遍历，当遍历到第五个元素的时候，发现它等于 `9` ，那么返回它的下标为 `4` 。

要在上述数组中查找元素 `2` ，也是采用同样从左往右的方式，发现数组中并没有等于 `2` 的元素，那么遍历结束后，直接返回 `-1 `。

通过图文的描述，我相信读者已经理解了，我们这里直接写出代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 对每一个元素进行遍历
        for (int i = 0; i < nums.length; i++) {
            // 如果数组中某个元素等于目标元素，则直接返回元素下标
            if (target == nums[i]) {
                return i;
            }
        }
        
        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

复杂度分析：

- 时间复杂度：$O(n)$
- 空间复杂度： $O(1)$

我们做完这一道题，也分析了时间复杂度，那么有办法降低这个时间复杂度吗？或者说，有更优的解法吗？答案是当然有，它就是本节的重点要介绍的解法： `二分查找法` 。

## 二、二分查找算法

### 2.1 什么是二分查找

何为 **『二分查找』** ？相信刚刚接触数据结构与算法的读者可能会懵，不急，我举个生活中出现过的例子，相信这类读者肯定会很快明白。

以前看过一档综艺节目，主持人手中有 `100` 牌，每张牌中都有一个数字，数字分别是从 `1` 到 `100` ，主持人让嘉宾随机抽取一张，然后主持人要在极短的时间内猜中嘉宾抽中的牌是哪一个数字（假设本次读者抽中的是 `79` ），主持人不可以直接问嘉宾牌上数字是多少，嘉宾只用回答 `是` 或者 `不是` ，那么这个时候，他们之间的对话就开始了。

**主持人：** “您手中的牌数字大于 `50` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌数字大于 `75` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌数字大于 `88` 吗？”

**嘉    宾：** “不是”

**主持人：** “您手中的牌数字大于 `81` 吗？”

**嘉    宾：** “不是”

**主持人：** “您手中的牌数字大于 `78` 吗？”

**嘉    宾：** “是”

**主持人：** “您手中的牌大于 `79` 吗？”

**嘉    宾：** “不是”

**主持人：** “我猜出来了，您手中的牌数字是 `79` ！”

**嘉    宾：** “恭喜您，答对了！”

相信这个综艺节目的这种案例大家都看过或者听过，主持人在问了嘉宾六个问题后，第七次就直接猜中了嘉宾抽取的牌数字。如果说，主持人从数字 `1` 开始挨个问：“您牌的数字是不是 `1` ...”，那么他需要问 `79` 次才能问中，假设主持从 `100` 倒序往前问，也得问 `21` 次才可以问到答案。

其实，主持人这种问法，正是经典的 **『减而治之』** 的思想，也是 **『二分查找算法』** 的应用。 **『减而治之』** 思想就是：一步步缩小问题范围，在小范围中去解决问题。主持人通过问嘉宾手中的牌数字是否比某个值大，从而来缩小范围，最终确定了范围是 `[79, 80]` ，那么通过最后一个问题直接判断出答案是 `79` 。

我们将 `1 ~ 100` 的牌理解为 `[1, 2, 3, ..., 99, 100]` 的数组，那么我们再来思考下何为 **『二分查找』** ，相信读者肯定就容易理解多了。顾名思义，就是将数组一分为二，排除掉不可能的二分之一数组，继续从剩下二分之一数组中去查找，这种查找算法最基本的条件就是数组要有序，它是一种在有序数组中查找某一特定元素的搜索算法。二分查找算法的叫法也很多，常见的有： **折半查找算法** 、 **对半查找算法** 、 **对数查找算法** 等。

上面的综艺节目的案例，其实是 **『二分查找算法』** 的 `排除法` 的应用，它直接排除了不可能的区间，直到最后只剩下一个元素，直接判断最后剩下的元素是否等于目标元素即可。其实还有一种思路，那就是 `主动找` ，它是  **『二分查找算法』** 里常见的思路，理解起来比 `排除法` 思路还简单一些。它的基本过程如下：

1. 拿到一个数组（默认数组有序）以后，直接找到数组的中间元素，如果中间元素正好等于目标元素，则搜索过程结束，直接返回中间元素的下标即可；
2. 如果目标元素大于（小于）中间元素，则在数组大于（小于）中间元素的那一半中查找，而且跟开始一样，从中间元素开始比较；
3. 如果找到最后，数组为空了，则代表找不到，返回 `-1` 即可。

对于这种 `主动找` 的思路，我也来举个例子，给定一个有序数组 `[1, 2, 4, 16, 17, 19, 20, 21, 23, 31, 39]` ，我们需要判断 `21` 是否在数组中，如果在，返回它在数组中的下标，如果不在，直接返回 `-1` 。

我们根据上面 `主动找` 的基本过程来看如何使用 **『二分查找算法』** 来快速找到结果：

1. 首先找到中间元素 `19` ，它不等于 `21` ，因为 `21` 比 `19` 大，所以，我们需要在大于 `19` 的那一半去接着找，此时寻找区间变成了`[20, 21, 23, 31, 39]` ；
2. 我们在 `[20, 21, 23, 31, 39]` 这一半找到中间元素 `23` ，它不等于 `21` ，它比 `21` 大，所以我们需要到小于 `23` 的那一半去接着找，此时寻找区间变成了 `[20, 21]` ；
3. 此时寻找空间就剩下两个元素，我们找中间元素，元素 `20` 的下标是 `6` ，元素 `21` 的下标是 `7` ，我们取两个下标之和除以 `2` ，在计算机整型中 **除以** 有向下取整的过程， `13 / 2 = 6` ，所以中间元素为 `20` ，此时继续判断 `21` 大于 `20` ，所以需要在 `20` 右边区间继续寻找，此时寻找区间变成了 `[21]` ；
4. 最后一步，自然而然， `21` 成为了中间元素，它等于目标元素，所以此时找到了结果，返回 `21` 的下标为 `7` 。

我们通过 **『二分查找算法』** 来搜索元素，只搜索了 `4` 次就找到了目标元素，如果挨个儿遍历，那也需要遍历 `8` 次才能找到，所以说， **『二分查找算法』** 是比普通遍历更优的算法。

### 2.2 使用语言实现二分查找算法

我们还是以第一小节中的经典案例来举例，我们这次尝试使用二分查找算法来解决这个搜索问题。首先，我们还是通过画图的形式，将过程展示出来，过程理清楚了，代码写起来就不难了，图文过程如下所示：

首先我们定义三个变量：

- left：左边界下标
- right：右边界下标
- mid：中间值下标

初始值设置为： `left = 0` ， `right = nums.length - 1` ， `mid = (left + right) / 2`

数组的搜索区间为 `[left, right]` ，中间值的下标为 `mid` ，我们按照 `主动找` 的思路来解决这个问题，基本步骤如下：

- 如果中间位置值 `nums[mid]` 与目标值 `target` 相等，则返回中间值下标；
- 如果中间位置值 `nums[mid]` 小于目标值 `target` ，说明如果目标值存在，则一定在中间值的右区间，此时将左边界设置为 `mid + 1` ，然后继续在右区间 `[mid + 1, right]` 中搜索；
- 如果中间位置值 `nums[mid]` 大于目标值 `target`，说明如果目标值存在，则一定在中间值的左区间，此时将右边界设置为 `mid - 1` ，然后继续在左区间 `[left, mid - 1]` 中搜索。

转换成图形式如下所示：

![image-20221026000105068](https://codingguide-1256975789.cos.ap-beijing.myqcloud.com/codingguide/img/image-20221026000105068.png)

从上面的图文可以看出，我们通过 2 次就找到了目标值，效率是杠杠的！

我们一起来看下代码如何实现，这里直接给出代码如下：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义三个变量
        int left = 0;
        int right = nums.length - 1;
        int mid;

        // 跳出循环的条件是 left > right，当left == right的时候，是最后一次循环，此时待查找区间只剩下一个元素
        // 如果最后一个元素不等于目标元素，说明数组nums里面不含目标元素，直接返回 -1
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        // 如果不存在目标元素，直接返回-1
        return -1;
    }
}
```

复杂度分析：

- 时间复杂度：$O(\log_{2}{n})$
- 空间复杂度： $O(1)$

